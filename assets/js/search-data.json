{
  
    
        "post0": {
            "title": "x509 Certificate Fingerprinting In Golang",
            "content": "This website serves content to your browser over an encrypted and authenticated tunnel. The S in https stands for secure via TLS (Transport Layer Security). To do so, it relies on a public key certificate associated with the domain name and issued by a certificate authority (CA) which acts as a trusted third party. I&#39;m using github pages to host this page. Looking at the certificate in Brave&#39;s certificate viewer, you see github pages uses lets encrypt as the CA. (If you are looking at this tutorial after November 4th, 2020, you&#39;ll see different values.) . . Looking at the same viewer, you&#39;ll also notice that Brave shows two fingerprints: one for the (no longer secure) SHA-1 algorithm and the other for the SHA256, a 512 bit block hash in the SHA-2 family. If you aren&#39;t doing much work with public key cryptography, this may be the first time you noticed the fingerprint section. However, if you use computers in any sophisticated capacity, you&#39;ve probably probably have seen hashes of public key artifacts in other contexts. In particular, you may have seen a message like this, . The authenticity of host &#39;&lt;host&gt;&#39; can&#39;t be established. ECDSA key fingerprint is SHA256:&lt;BASE64-encoded-SHA256-Fingerprint&gt;. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &#39;&lt;host&gt;&#39; (ECDSA) to the list of known hosts. . when connecting to a new SSH host using OpenSSH. This user experience is called TOFU: Trust on First Use. Since SSH has not seen this key before (or rather, it&#39;s fingerprint) it prompts you whether or not you would like to trust it. If you confirm with y, future sessions won&#39;t prompt you again, so long as the fingerprint of the key does not change. . While TOFU is a questionable practice with respect to security (how often do you actually confirm the fingerprint with an administrator or in some database before confirmation?), this use of fingerprinting is common in applications using TLS. This notebook shows you how to use both OpenSSL and golang to extract equivalent fingerprints. It is fully self-contained — if you have a Golang kernel for Jupyter, you can run it. . Gold Values from OpenSSL and a PEM-encoded File . First, we&#39;ll set up our imports. If you do any public key cryptography in golang, most of these will be familiar. . import ( &quot;crypto/md5&quot; &quot;crypto/sha1&quot; &quot;crypto/sha256&quot; &quot;crypto/tls&quot; &quot;crypto/x509&quot; &quot;encoding/pem&quot; &quot;fmt&quot; &quot;hash&quot; &quot;os&quot; &quot;os/exec&quot; &quot;io/ioutil&quot; &quot;strings&quot; ) . Next, we&#39;ll write a fixed, minimal ASCII/PEM-encoded certificate so that this tutorial won&#39;t change over time. . const knownCert = `--BEGIN CERTIFICATE-- MIIBUzCB+qADAgECAhR7l0x6Cgyt0hWRxQXKDB4NIgKM2TAKBggqhkjOPQQDAjAN MQswCQYDVQQGEwJVSzAeFw0yMDA4MTIyMzIwMTBaFw0zMDA4MTAyMzIwMTBaMA0x CzAJBgNVBAYTAlVLMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEJBJm0831oqwg 6daZcuB+vgeRFinuuT6hU2NxboDbfeyGUjv91lBWnCU1YL27d7PhZVabyNtQm0OZ bmveMV9v7aM4MDYwDgYDVR0PAQH/BAQDAgKEMBMGA1UdJQQMMAoGCCsGAQUFBwMB MA8GA1UdEwEB/wQFMAMBAf8wCgYIKoZIzj0EAwIDSAAwRQIgWawEXk36iBObsLyr ZPzIlIN91/85aix5kYRxAPDIkOUCIQDxsqXNpb6hFTiwLnj2stl2hwcxtcTB8bnS gniTVdxCTw== --END CERTIFICATE-- ` const certFile = &quot;test.crt&quot; err := ioutil.WriteFile(certFile, []byte(knownCert), os.ModePerm) if err != nil { panic(err) } . With a certificate in hand (on disk), we can use openssl to compute the fingerprints. OpenSSL is robust and enjoys the battle-tested upside of Linus&#39;s Law, so it&#39;s a useful way to compute the expected outputs using MD5, SHA1, SHA256. . // Extract the fingerprint from command execution in a generic way func extractFingerprint(cmd *exec.Cmd) string { b, err := cmd.Output() if err != nil { panic(err) } return strings.Split(strings.TrimSpace(string(b)), &quot;=&quot;)[1] } knownMD5 := extractFingerprint(exec.Command(&quot;openssl&quot;, &quot;x509&quot;, &quot;-noout&quot;, &quot;-fingerprint&quot;, &quot;-md5&quot;, &quot;-in&quot;, certFile)) knownSHA1 := extractFingerprint(exec.Command(&quot;openssl&quot;, &quot;x509&quot;, &quot;-noout&quot;, &quot;-fingerprint&quot;, &quot;-sha1&quot;, &quot;-in&quot;, certFile)) knownSHA256 := extractFingerprint(exec.Command(&quot;openssl&quot;, &quot;x509&quot;, &quot;-noout&quot;, &quot;-fingerprint&quot;, &quot;-sha256&quot;, &quot;-in&quot;, certFile)) _, _ := fmt.Printf(&quot;MD5 = %s nSHA1 = %s nSHA256 = %s n&quot;, knownMD5, knownSHA1, knownSHA256) . MD5 = 04:56:1B:6C:AF:DE:39:72:18:74:AE:E0:F9:5B:2D:DE SHA1 = 3A:1F:3B:C0:B3:A4:5B:FE:D6:D7:87:5E:C7:1D:E4:C4:7B:EA:B0:C0 SHA256 = D7:AD:9F:D5:C4:F4:BD:23:7B:DE:BF:7F:30:C0:D8:99:7A:C8:72:94:DE:DA:25:C7:4E:6C:3B:06:C4:EB:4E:C0 . Fingerprinting without x509 Parsing . With the gold values computed, we can now use Go, instead. First, we&#39;ll load the certificate file and decode the PEM data. . b, err := ioutil.ReadFile(certFile) if err != nil { panic(err) } block, _ := pem.Decode(b) if block == nil { panic(&quot;doesn&#39;t seem like a PEM block&quot;) } . Now, we&#39;ll compute the MD5, SHA1, and SHA256, hashes from the PEM block&#39;s Bytes field. . // Normalize the hash so it is equal to the openssl output func normalizeHash(h hash.Hash, b []byte) string { _, err := h.Write(b) if err != nil { panic(err) } digest := h.Sum([]byte{}) var parts []string for _, octet := range digest { parts = append(parts, fmt.Sprintf(&quot;%02X&quot;, octet)) } return strings.Join(parts, &quot;:&quot;) } _, _ := fmt.Printf(&quot;MD5 Equal = %v nSHA1 Equal = %v nSHA256 Equal = %v n&quot;, normalizeHash(md5.New(), block.Bytes) == knownMD5, normalizeHash(sha1.New(), block.Bytes) == knownSHA1, normalizeHash(sha256.New(), block.Bytes) == knownSHA256, ) . MD5 Equal = true SHA1 Equal = true SHA256 Equal = true . They are equal. The go code and the OpenSSL commands compute the same thing. . Fingerprinting with x509 Parsing . This part is a little contrived. But, often you have ready access to a *x509.Certificate. If you do, the Raw field contains the same data as the block bytes, . cert, err := x509.ParseCertificate(block.Bytes) if block == nil { panic(&quot;doesn&#39;t seem like a PEM block&quot;) } _, _ := fmt.Printf(&quot;MD5 Equal = %v nSHA1 Equal = %v nSHA256 Equal = %v n&quot;, normalizeHash(md5.New(), cert.Raw) == knownMD5, normalizeHash(sha1.New(), cert.Raw) == knownSHA1, normalizeHash(sha256.New(), cert.Raw) == knownSHA256, ) . MD5 Equal = true SHA1 Equal = true SHA256 Equal = true . Fingerprinting from a Peer Certificate . Finally, most code that uses net makes the peer certificates for an active connection available in some way. This example shows how to take the fingerprint of that certificate. . conn, err := tls.Dial(&quot;tcp&quot;, &quot;code.johnbnelson.com:443&quot;, &amp;tls.Config{}) if err != nil { panic(err) } // There may be more than one certificate. This example may break. fetchedCert := conn.ConnectionState().PeerCertificates[0] conn.Close() normalizeHash(sha256.New(), fetchedCert.Raw) . D7:AB:C0:10:83:65:B2:59:CA:88:5B:94:43:EF:86:E5:49:B6:F0:57:38:4F:4F:33:BA:27:8C:DB:D6:D2:88:2B . Conclusion . Go is batteries included from the perspective of public key cryptography. The most complicated part of this tutorial was string manipulation, which you don&#39;t have to actually do. The only general parting advice is, as always, don&#39;t use MD5 or SHA1 — they are insecure. .",
            "url": "https://code.johnbnelson.com/go/crypto/2020/08/12/certificate-fingerprinting-in-golang.html",
            "relUrl": "/go/crypto/2020/08/12/certificate-fingerprinting-in-golang.html",
            "date": " • Aug 12, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "My name is Johnny. . You can find me on twitter as @generativist I talk a lot on there. .",
          "url": "https://code.johnbnelson.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://code.johnbnelson.com/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}