{
  
    
        "post0": {
            "title": "Length-Prefixed Protobuf Messages",
            "content": "Protocol buffers are popular, especially indirectly via gRPC. If you are using golang, you may use the official golang/protobuf package. But, there are other implementations. In particular, gogo/protobuf does protocol buffers in go without reflection, and with smarter allocations to reduce gc pressure. The result is better performance. . The README does a good job of getting you started. However, if you are using protobuf without gRPC, you&#39;ll quickly find yourself in need of a serialization format for delimiting messages. The easiest way to do this is with length-prefixing. What I failed to realize for far too long is that gogo/protobuf tools for this already. . Looking at github.com/gogo/protobuf/io, there is . func NewDelimitedReader(r io.Reader, maxSize int) ReadCloser { var closer io.Closer if c, ok := r.(io.Closer); ok { closer = c } return &amp;varintReader{bufio.NewReader(r), nil, maxSize, closer} } . and, . func NewDelimitedWriter(w io.Writer) WriteCloser { return &amp;varintWriter{w, make([]byte, binary.MaxVarintLen64), nil} } . The reader has a ReadMsg function, . func (this *varintReader) ReadMsg(msg proto.Message) error { . and the writer has a WriteMsg function, . func (this *varintWriter) WriteMsg(msg proto.Message) (err error) . Both these methods use encoding/binary&#39;s Uvarint, allowing for very large messages — no need to roll your own. . Depending on your protocol/serialization needs, it may be useful to use a TLV encoding. Given DelimitedReader and DelimitedWriter, the easiest way to do this is to write the type as a byte before each length-delimited message is sent. I generally define mine in the protocol file as an enum, since it&#39;s self documenting. . Anyways, nothing in this post is new or interesting. It&#39;s just that I didn&#39;t realize it was already built into a dependency I was using anyway, so hopefully I&#39;ll save you a stack-overflow trip. .",
            "url": "https://code.johnbnelson.com/go/protobuf/2020/08/20/protobuf-length-prefixing.html",
            "relUrl": "/go/protobuf/2020/08/20/protobuf-length-prefixing.html",
            "date": " • Aug 20, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "x509 Certificate Fingerprinting In Golang",
            "content": "This website serves content to your browser over an encrypted and authenticated tunnel. The S in https stands for secure via TLS (Transport Layer Security). To do so, it relies on a public key certificate associated with the domain name and issued by a certificate authority (CA) which acts as a trusted third party. I&#39;m using github pages as my host. Looking at the certificate in Brave&#39;s certificate viewer, you see github pages uses lets encrypt as the CA (it&#39;s free). . (If you are looking at this tutorial after November 4th, 2020, you&#39;ll see different values.) . . Looking at the same viewer, you&#39;ll also notice that Brave shows two fingerprints: one for the (no longer secure) SHA-1 algorithm and the other for the SHA256, a 512 bit block secure hash in the SHA-2 family. If you aren&#39;t doing much work with public key cryptography, this may be the first time you noticed the fingerprint section. However, if you use computers in any sophisticated capacity, you&#39;ve probably probably have seen hashes of public key artifacts in other contexts. In particular, you may have seen a message like this, . The authenticity of host &#39;&lt;host&gt;&#39; can&#39;t be established. ECDSA key fingerprint is SHA256:&lt;BASE64-encoded-SHA256-Fingerprint&gt;. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &#39;&lt;host&gt;&#39; (ECDSA) to the list of known hosts. . when connecting to a new SSH host using OpenSSH. This user experience is called TOFU: Trust on First Use. Since OpenSSH has not seen this key before (or rather, it&#39;s fingerprint) it asks whether or not you would like to trust it. If you confirm with y, future sessions won&#39;t prompt you again, so long as the fingerprint of the key does not change. . While TOFU is a questionable practice with respect to security (how often do you actually confirm the fingerprint with an administrator or in some database before confirmation?), this use of fingerprinting is common in applications using TLS. This notebook shows you how to use both OpenSSL and golang to extract equivalent fingerprints. It is fully self-contained — if you have a Golang kernel (I use gophernotes) for Jupyter, you can run it. . Gold Values from OpenSSL and a PEM-encoded File . First, we&#39;ll set up our imports. If you do any public key cryptography in golang, most of these will be familiar. . import ( &quot;crypto/md5&quot; &quot;crypto/sha1&quot; &quot;crypto/sha256&quot; &quot;crypto/tls&quot; &quot;crypto/x509&quot; &quot;encoding/pem&quot; &quot;fmt&quot; &quot;hash&quot; &quot;os&quot; &quot;os/exec&quot; &quot;io/ioutil&quot; &quot;strings&quot; ) . Next, we&#39;ll write a fixed, minimal ASCII/PEM-encoded certificate so that this tutorial won&#39;t change over time. . const knownCert = `--BEGIN CERTIFICATE-- MIIBUzCB+qADAgECAhR7l0x6Cgyt0hWRxQXKDB4NIgKM2TAKBggqhkjOPQQDAjAN MQswCQYDVQQGEwJVSzAeFw0yMDA4MTIyMzIwMTBaFw0zMDA4MTAyMzIwMTBaMA0x CzAJBgNVBAYTAlVLMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEJBJm0831oqwg 6daZcuB+vgeRFinuuT6hU2NxboDbfeyGUjv91lBWnCU1YL27d7PhZVabyNtQm0OZ bmveMV9v7aM4MDYwDgYDVR0PAQH/BAQDAgKEMBMGA1UdJQQMMAoGCCsGAQUFBwMB MA8GA1UdEwEB/wQFMAMBAf8wCgYIKoZIzj0EAwIDSAAwRQIgWawEXk36iBObsLyr ZPzIlIN91/85aix5kYRxAPDIkOUCIQDxsqXNpb6hFTiwLnj2stl2hwcxtcTB8bnS gniTVdxCTw== --END CERTIFICATE-- ` const certFile = &quot;test.crt&quot; err := ioutil.WriteFile(certFile, []byte(knownCert), os.ModePerm) if err != nil { panic(err) } . With a certificate in hand (on disk), we can use openssl to compute the fingerprints. OpenSSL is robust and enjoys the battle-tested upside of Linus&#39;s Law, so it&#39;s a useful way to compute the expected outputs using MD5, SHA1, SHA256. . // Extract the fingerprint from command execution in a generic way func extractFingerprint(cmd *exec.Cmd) string { b, err := cmd.Output() if err != nil { panic(err) } return strings.Split(strings.TrimSpace(string(b)), &quot;=&quot;)[1] } knownMD5 := extractFingerprint(exec.Command(&quot;openssl&quot;, &quot;x509&quot;, &quot;-noout&quot;, &quot;-fingerprint&quot;, &quot;-md5&quot;, &quot;-in&quot;, certFile)) knownSHA1 := extractFingerprint(exec.Command(&quot;openssl&quot;, &quot;x509&quot;, &quot;-noout&quot;, &quot;-fingerprint&quot;, &quot;-sha1&quot;, &quot;-in&quot;, certFile)) knownSHA256 := extractFingerprint(exec.Command(&quot;openssl&quot;, &quot;x509&quot;, &quot;-noout&quot;, &quot;-fingerprint&quot;, &quot;-sha256&quot;, &quot;-in&quot;, certFile)) _, _ := fmt.Printf(&quot;MD5 = %s nSHA1 = %s nSHA256 = %s n&quot;, knownMD5, knownSHA1, knownSHA256) . MD5 = 04:56:1B:6C:AF:DE:39:72:18:74:AE:E0:F9:5B:2D:DE SHA1 = 3A:1F:3B:C0:B3:A4:5B:FE:D6:D7:87:5E:C7:1D:E4:C4:7B:EA:B0:C0 SHA256 = D7:AD:9F:D5:C4:F4:BD:23:7B:DE:BF:7F:30:C0:D8:99:7A:C8:72:94:DE:DA:25:C7:4E:6C:3B:06:C4:EB:4E:C0 . Fingerprinting without x509 Parsing . With the gold values computed, we can now use Go, instead. First, we&#39;ll load the certificate file and decode the PEM data. . b, err := ioutil.ReadFile(certFile) if err != nil { panic(err) } block, _ := pem.Decode(b) if block == nil { panic(&quot;doesn&#39;t seem like a PEM block&quot;) } . Now, we&#39;ll compute the MD5, SHA1, and SHA256, hashes from the PEM block&#39;s Bytes field. . // Normalize the hash so it is equal to the openssl output func normalizeHash(h hash.Hash, b []byte) string { _, err := h.Write(b) if err != nil { panic(err) } digest := h.Sum([]byte{}) var parts []string for _, octet := range digest { parts = append(parts, fmt.Sprintf(&quot;%02X&quot;, octet)) } return strings.Join(parts, &quot;:&quot;) } _, _ := fmt.Printf(&quot;MD5 Equal = %v nSHA1 Equal = %v nSHA256 Equal = %v n&quot;, normalizeHash(md5.New(), block.Bytes) == knownMD5, normalizeHash(sha1.New(), block.Bytes) == knownSHA1, normalizeHash(sha256.New(), block.Bytes) == knownSHA256, ) . MD5 Equal = true SHA1 Equal = true SHA256 Equal = true . They are equal. The go code and the OpenSSL commands compute the same thing. . Fingerprinting with x509 Parsing . This part is a little contrived. But, often you have ready access to a *x509.Certificate. If you do, the Raw field contains the same data as the block bytes, . cert, err := x509.ParseCertificate(block.Bytes) if block == nil { panic(&quot;doesn&#39;t seem like a PEM block&quot;) } _, _ := fmt.Printf(&quot;MD5 Equal = %v nSHA1 Equal = %v nSHA256 Equal = %v n&quot;, normalizeHash(md5.New(), cert.Raw) == knownMD5, normalizeHash(sha1.New(), cert.Raw) == knownSHA1, normalizeHash(sha256.New(), cert.Raw) == knownSHA256, ) . MD5 Equal = true SHA1 Equal = true SHA256 Equal = true . Fingerprinting from a Peer Certificate . Finally, most code that uses net makes the peer certificates for an active connection available in some way. This example shows how to take the fingerprint of that certificate. . conn, err := tls.Dial(&quot;tcp&quot;, &quot;code.johnbnelson.com:443&quot;, &amp;tls.Config{}) if err != nil { panic(err) } // There may be more than one certificate. This example may break. fetchedCert := conn.ConnectionState().PeerCertificates[0] conn.Close() normalizeHash(sha256.New(), fetchedCert.Raw) . D7:AB:C0:10:83:65:B2:59:CA:88:5B:94:43:EF:86:E5:49:B6:F0:57:38:4F:4F:33:BA:27:8C:DB:D6:D2:88:2B . Conclusion . Go is batteries included from the perspective of public key cryptography. The most complicated part of this tutorial was string manipulation, which you don&#39;t have to actually do. The only general parting advice is, as always, don&#39;t use MD5 or SHA1 — they are wildly insecure and insecure, respectively. .",
            "url": "https://code.johnbnelson.com/go/crypto/2020/08/12/certificate-fingerprinting-in-golang.html",
            "relUrl": "/go/crypto/2020/08/12/certificate-fingerprinting-in-golang.html",
            "date": " • Aug 12, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "My name is Johnny. . You can find me on twitter as @generativist I talk a lot on there. .",
          "url": "https://code.johnbnelson.com/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://code.johnbnelson.com/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}